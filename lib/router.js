// Generated by CoffeeScript 1.7.1

/*

    Router for React.

    Use @Mixin on the client and @create on the server.

    On the client, @Mixin goes into the root component and sets
    route matches into props.matchedRoute.

    Expects a path list:

        routes =  [
            { path: "/",                 handler: Home },
            { path: "/writing",          handler: Writing },
            { path: "/writing/:slug",    handler: WritingView },
            { path: "*",                 handler: NotFound }
        ]

    When matchRoute(path) is called, a matchedRoute object
    is set into this.props:

        matchedRoute:
            path: "/writing/my-post"
            params:
                slug: "my-post"
            handler: WritingView
 */

(function() {
  var RouterMixin, closestTag, urlPattern, _;

  _ = require("underscore");

  urlPattern = require('url-pattern');

  closestTag = require("./utils").closestTag;

  RouterMixin = this.Mixin = {
    handleClick: function(e) {
      var link, _ref;
      if (link = closestTag(e.target, 'A')) {
        if (((_ref = link.getAttribute("href")) != null ? _ref[0] : void 0) === "/") {
          e.preventDefault();
          e.stopPropagation();
          return this.navigate(link.pathname);
        }
      }
    },
    handlePopstate: function() {
      var path;
      path = window.location.pathname;
      if (this.props.matchedRoute.path !== path) {
        return this.matchRoute(path, (function(_this) {
          return function(matchedRoute) {
            return _this.setProps({
              matchedRoute: matchedRoute
            });
          };
        })(this));
      }
    },
    componentDidMount: function() {
      window.addEventListener('popstate', this.handlePopstate);
      return window.Router = this;
    },
    matchStaticRoute: function(path) {
      var matchedRoute, params, pattern, route, _i, _len, _ref;
      if (path[path.length - 1] !== "/") {
        path += "/";
      }
      _ref = this.routes || [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        route = _ref[_i];
        if (route.path[route.path.length - 1] !== "/") {
          route.path += "/";
        }
        pattern = urlPattern.newPattern(route.path);
        params = pattern.match(path);
        if (params) {
          matchedRoute = {
            path: path,
            params: params,
            handler: route.handler
          };
        }
      }
      return matchedRoute || null;
    },
    matchRoute: function(path, callback, options) {
      var matchedRoute;
      if (options == null) {
        options = {};
      }
      if (path[path.length - 1] !== "/") {
        path += "/";
      }
      matchedRoute = this.matchStaticRoute(path);
      if (matchedRoute) {
        return callback(matchedRoute);
      } else {
        return this.fallbackRoute(path, function(matchedRoute) {
          return callback(matchedRoute);
        });
      }
    },
    navigate: function(path, callback) {
      return this.matchRoute(path, (function(_this) {
        return function(matchedRoute) {
          window.history.pushState(null, null, path);
          return _this.setProps({
            matchedRoute: matchedRoute
          }, callback);
        };
      })(this));
    }
  };

  this.create = function(routes) {
    var Router;
    Router = _.clone(RouterMixin);
    _.extend(Router, {
      routes: routes,
      add: function(route) {
        return this.routes.push(route);
      },
      addFallback: function(fallback) {
        return this.fallbackRoute = fallback;
      }
    });
    return Router;
  };

}).call(this);
